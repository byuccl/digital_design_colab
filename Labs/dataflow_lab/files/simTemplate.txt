/**
 *  \brief     main.cpp for verilator object
 *  \details
 *  \author    Reilly McKendrick, generated by verilator.py
 *  \date      2019
*/
#define DEFNUMINS ${NUMINS}
#include<iostream>
#include<fstream>
#include"verilated.h"
#include<bitset>
#include"TestBench___.h"
#include<iomanip>
#include<cmath>
#include<vector>
#include<sstream>
#include<string>

/*!
 * Convert a string to a uint64_t. Handles binary 'bx' hex '0x' and decimal input.
 * @param[in]  in  string to convert. Begins with either 'bx', '0x', '*', or just numbers
 * @param[in] line the current line number for printing error messages.
*/
uint64_t convert(std::string in, size_t &line) {
  uint64_t out;
  try {
    if(in[0] == '0' && in[1] == 'x') {
      out = stoull(in.substr(2, in.length() -1), NULL, 2);
    }
    else if (in[0] == 'b' && in[1] == 'x') {
      out = stoull(in.substr(2, in.length() -1), NULL, 16);
    }
    else if (in[0] == '*') {
      out = stoull(in.substr(1, in.length() -1));
    }
    else {
      out = stoull(in);
    }
  }
  catch (...) {
    std::cerr << "Invalid format of '" << in << "' on line " << line << std::endl;
    exit(6);
  }
  return out;
}

/*!
 * Splits a string by whitespace. returns a vector of tokens
 * @param[in] line  string to split
*/
std::vector<std::string> split(std::string line) {
  std::vector<std::string> words;
  std::string tmp;
  std::stringstream stream;
  stream << line;
  while(stream >> tmp) {
    if (tmp.substr(0,1) == "//") break;
    words.push_back(tmp);
  }
  return words;
}

/*!
 * Checks to see if the input number is the appropriate size bitwise. returns true if number is too big
 * @param[in] maxBits  maximum number of bits to compare test number to
 * @param[in] num number to test for bitsize
*/
bool errorCheck(size_t maxBits, uint64_t num) {
  size_t cnt = 0;
  while(num) {
    ++cnt;
    num >>= 1;
  }
  return (cnt > maxBits) ? true : false;
}

int main(int argc, char *argv[]) {
  Verilated::commandArgs(argc, argv);
  if (argc < 2) {
    std::cerr << "Please provide input file" << std::endl;
    return 1;
  }
  std::fstream in(argv[1]);
  if (!in) {
    std::cerr << "Unable to open " << argv[1] << " for input";
    return 2;
  }
  
  // Did the user specify "+trace"?
  bool trc = (argc > 2) && (std::string(argv[2]) == "--trace"); //analyze commandline arguments

  std::vector<std::string> inputs;
  std::string line;
  
  // Skip first two lines of input file.
  std::stringstream test;
  size_t ln = 1;
  for (int i = 0; i < 2; ++i) {
    do {
      std::getline(in, line);
      ln++;
    }  while((line[0] == '/') && (line[1] == '/'));
  }
  
  // Create TestBench class
  TestBench module(trc);
  
  std::setprecision(12);
  
  uint64_t num = 0;
  bool clock = false;
  
  size_t const NUM_INS = DEFNUMINS;
  
  while (!in.eof()) {
    std::getline(in, line);
    if ((line != "") && (line.substr(0, 1) != "//")) {
      inputs = split(line);
      size_t numTokens = inputs.size();
      if (numTokens > (NUM_INS + 1)) {
        std::cerr << "Too many inputs on line " << ln << ". Expected " << NUM_INS << " or " << NUM_INS + 1 << std::endl;
        return 3;
      }
      else if (numTokens == (NUM_INS + 1)) {
        clock = true;
        if (inputs[numTokens - 1][0] != '*') {
          std::cerr << "Unexpected input (" << inputs[numTokens - 1] <<") on line " << ln << ". Input should begin with '*'" << std::endl;
          return 4;
        }
      }
      else if (numTokens < NUM_INS) {
        std::cerr <<line << " Unexpected number of inputs (" << numTokens << ") on line " << ln << ". Expected " << NUM_INS << std::endl;
        return 6;
      }
      else clock = false;
      
      
      ////////////////////////////////////////////////////////////////
      // Design-specific code
      size_t i = 0;

${READINPUTSCODE}
      // Simulate this line...
      if (clock)
        module.toggleClk(convert(inputs[i], ln), ${HASCLOCK});
      else
        module.toggleClk(1, ${HASCLOCK});
      ln++;
    }
  } // end while
  return 0;
} // main
